# CI-02: 認證與工作區狀態管理整合修復指南

## 📋 修復任務概述

- **修復ID**: CI-02
- **優先級**: Critical 🔴
- **預估工期**: 1 週
- **負責團隊**: 前端團隊
- **影響範圍**: 用戶登入後的工作區選擇與初始化流程

## 🎯 問題定義

### 問題描述
前端認證系統 (AuthWrapper) 與工作區管理系統 (WorkspaceContext) 存在分離狀態，導致用戶登入成功後無法自動進入工作區，需要手動操作才能開始使用系統功能。

### 根本原因分析
1. **狀態管理獨立**: AuthWrapper 和 WorkspaceContext 各自管理狀態，缺乏有效的狀態同步機制
2. **初始化順序混亂**: 認證完成後沒有明確的工作區初始化流程
3. **錯誤處理不一致**: 兩個系統的錯誤處理策略不統一
4. **用戶體驗斷層**: 登入成功後缺少平滑的導向流程

### 當前狀況詳細分析

#### 現有 AuthWrapper 實作分析
```typescript
// src/components/auth/AuthWrapper.tsx - 當前狀況
export const AuthWrapper: React.FC<AuthWrapperProps> = ({ children }) => {
  // ✅ 認證狀態管理完整
  const [authState, setAuthState] = useState<AuthState>({
    isAuthenticated: false,
    user: null,
    loading: true,
    error: null
  });

  // ❌ 缺乏與工作區狀態的整合
  // ❌ 登入成功後沒有自動載入工作區
  // ❌ 錯誤狀態處理不完整
};
```

#### 現有 WorkspaceContext 實作分析
```typescript
// src/contexts/WorkspaceContext.tsx - 當前狀況
export const WorkspaceProvider: React.FC<WorkspaceProviderProps> = ({ children }) => {
  // ✅ 工作區狀態管理基本完整
  const workspaceStore = useWorkspaceStore();
  
  // ❌ 缺乏與認證狀態的同步
  // ❌ 沒有自動初始化邏輯
  // ❌ 未處理認證失效的情況
};
```

## 🔧 詳細修復步驟

### 步驟 1: 建立整合的狀態管理架構 (2 天)

#### 1.1 創建統一的應用狀態 Hook

**新檔案**: `src/hooks/useAppState.ts`

```typescript
/**
 * 統一的應用狀態管理 Hook
 * 整合認證、工作區、UI 狀態
 */
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '../components/auth/AuthWrapper';
import { useWorkspaceStore } from '../stores/workspace';
import { User, Workspace } from '../types/api';

export interface AppState {
  // 認證狀態
  isAuthenticated: boolean;
  user: User | null;
  authLoading: boolean;
  authError: string | null;
  
  // 工作區狀態
  currentWorkspace: Workspace | null;
  workspaces: Workspace[];
  workspaceLoading: boolean;
  workspaceError: string | null;
  
  // 整合狀態
  isAppReady: boolean; // 認證 + 工作區都完成
  initializationStage: 'idle' | 'auth' | 'workspace' | 'complete' | 'error';
  
  // 操作方法
  retryInitialization: () => Promise<void>;
  logout: () => Promise<void>;
  switchWorkspace: (workspaceId: string) => Promise<boolean>;
  createWorkspace: (name: string) => Promise<Workspace | null>;
}

export const useAppState = (): AppState => {
  const [initializationStage, setInitializationStage] = useState<AppState['initializationStage']>('idle');
  const [retryCount, setRetryCount] = useState(0);
  
  // 認證狀態
  const { 
    isAuthenticated, 
    user, 
    loading: authLoading, 
    error: authError,
    logout: authLogout 
  } = useAuth();
  
  // 工作區狀態
  const workspaceStore = useWorkspaceStore();
  
  // 計算整合狀態
  const isAppReady = isAuthenticated && 
                    workspaceStore.currentWorkspaceId !== null && 
                    !authLoading && 
                    !workspaceStore.isLoading;

  // 初始化流程
  const initializeApp = useCallback(async () => {
    if (!isAuthenticated || !user) {
      setInitializationStage('auth');
      return;
    }

    try {
      setInitializationStage('workspace');
      
      // 1. 載入用戶工作區
      console.log('Loading workspaces for user:', user.id);
      await workspaceStore.refreshWorkspaces();
      
      // 2. 檢查是否有工作區
      if (workspaceStore.workspaces.length === 0) {
        console.log('No workspaces found, creating default workspace');
        const defaultWorkspace = await workspaceStore.createWorkspace('我的研究');
        
        if (!defaultWorkspace) {
          throw new Error('Failed to create default workspace');
        }
      }
      
      // 3. 選擇工作區
      if (!workspaceStore.currentWorkspaceId) {
        const targetWorkspace = workspaceStore.workspaces[0];
        console.log('Switching to workspace:', targetWorkspace.name);
        
        const success = await workspaceStore.switchToWorkspace(targetWorkspace.id);
        if (!success) {
          throw new Error('Failed to switch to workspace');
        }
      }
      
      setInitializationStage('complete');
      setRetryCount(0);
      
    } catch (error) {
      console.error('App initialization failed:', error);
      setInitializationStage('error');
      
      // 自動重試機制 (最多3次)
      if (retryCount < 3) {
        setTimeout(() => {
          setRetryCount(prev => prev + 1);
          initializeApp();
        }, 2000 * (retryCount + 1)); // 遞增延遲
      }
    }
  }, [isAuthenticated, user, workspaceStore, retryCount]);

  // 認證狀態變化時觸發初始化
  useEffect(() => {
    if (isAuthenticated && user && initializationStage === 'idle') {
      initializeApp();
    } else if (!isAuthenticated) {
      setInitializationStage('auth');
      workspaceStore.clearAllWorkspaces();
    }
  }, [isAuthenticated, user, initializationStage, initializeApp]);

  // 手動重試初始化
  const retryInitialization = useCallback(async () => {
    setRetryCount(0);
    setInitializationStage('idle');
    await initializeApp();
  }, [initializeApp]);

  // 整合的登出邏輯
  const logout = useCallback(async () => {
    try {
      // 先清理工作區狀態
      workspaceStore.clearAllWorkspaces();
      setInitializationStage('idle');
      
      // 再執行認證登出
      await authLogout();
      
    } catch (error) {
      console.error('Logout failed:', error);
    }
  }, [workspaceStore, authLogout]);

  return {
    // 認證狀態
    isAuthenticated,
    user,
    authLoading,
    authError,
    
    // 工作區狀態
    currentWorkspace: workspaceStore.currentWorkspace,
    workspaces: workspaceStore.workspaces,
    workspaceLoading: workspaceStore.isLoading,
    workspaceError: workspaceStore.error,
    
    // 整合狀態
    isAppReady,
    initializationStage,
    
    // 操作方法
    retryInitialization,
    logout,
    switchWorkspace: workspaceStore.switchToWorkspace,
    createWorkspace: workspaceStore.createWorkspace
  };
};
```

#### 1.2 創建應用狀態提供者

**新檔案**: `src/contexts/AppStateContext.tsx`

```typescript
/**
 * 應用狀態上下文提供者
 * 為整個應用提供統一的狀態管理
 */
import React, { createContext, useContext, ReactNode } from 'react';
import { useAppState, AppState } from '../hooks/useAppState';

const AppStateContext = createContext<AppState | null>(null);

interface AppStateProviderProps {
  children: ReactNode;
}

export const AppStateProvider: React.FC<AppStateProviderProps> = ({ children }) => {
  const appState = useAppState();
  
  return (
    <AppStateContext.Provider value={appState}>
      {children}
    </AppStateContext.Provider>
  );
};

// 使用應用狀態的 Hook
export const useAppStateContext = (): AppState => {
  const context = useContext(AppStateContext);
  
  if (!context) {
    throw new Error('useAppStateContext must be used within an AppStateProvider');
  }
  
  return context;
};

// 特定用途的便利 Hooks

/**
 * Hook: 確保應用完全就緒
 */
export const useRequireAppReady = () => {
  const appState = useAppStateContext();
  
  if (!appState.isAppReady) {
    throw new Error('App is not fully initialized');
  }
  
  return {
    user: appState.user!,
    workspace: appState.currentWorkspace!,
    isReady: true
  };
};

/**
 * Hook: 應用初始化狀態檢查
 */
export const useAppInitialization = () => {
  const { initializationStage, retryInitialization, authError, workspaceError } = useAppStateContext();
  
  const hasError = authError || workspaceError || initializationStage === 'error';
  const isInitializing = ['auth', 'workspace'].includes(initializationStage);
  
  return {
    stage: initializationStage,
    isInitializing,
    hasError,
    error: authError || workspaceError || '初始化失敗',
    retry: retryInitialization
  };
};
```

### 步驟 2: 重構主應用結構 (2 天)

#### 2.1 更新 App.tsx 整合新的狀態管理

**檔案**: `src/App.tsx`

```typescript
import React from 'react';
import { BrowserRouter as Router } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { AuthWrapper } from './components/auth/AuthWrapper';
import { WorkspaceProvider } from './contexts/WorkspaceContext';
import { AppStateProvider } from './contexts/AppStateContext';
import { MainApplication } from './components/MainApplication';
import { AppInitializationScreen } from './components/AppInitializationScreen';
import { ErrorBoundary } from './components/common/ErrorBoundary';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: 2,
    },
  },
});

const App: React.FC = () => {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <Router>
          <AuthWrapper>
            <WorkspaceProvider>
              <AppStateProvider>
                <AppRouter />
              </AppStateProvider>
            </WorkspaceProvider>
          </AuthWrapper>
        </Router>
      </QueryClientProvider>
    </ErrorBoundary>
  );
};

// 應用路由邏輯
const AppRouter: React.FC = () => {
  const { 
    isAppReady, 
    initializationStage, 
    isAuthenticated 
  } = useAppStateContext();
  
  // 未認證時顯示登入頁面
  if (!isAuthenticated) {
    return <LoginPage />;
  }
  
  // 認證成功但應用未就緒時顯示初始化畫面
  if (!isAppReady) {
    return <AppInitializationScreen stage={initializationStage} />;
  }
  
  // 應用完全就緒時顯示主應用
  return <MainApplication />;
};

export default App;
```

#### 2.2 創建應用初始化畫面

**新檔案**: `src/components/AppInitializationScreen.tsx`

```typescript
/**
 * 應用初始化畫面
 * 顯示登入後的工作區載入進度
 */
import React from 'react';
import { LoadingSpinner } from './common/LoadingSpinner';
import { RetryButton } from './common/RetryButton';
import { useAppInitialization } from '../contexts/AppStateContext';

interface AppInitializationScreenProps {
  stage: 'idle' | 'auth' | 'workspace' | 'complete' | 'error';
}

export const AppInitializationScreen: React.FC<AppInitializationScreenProps> = ({ stage }) => {
  const { isInitializing, hasError, error, retry } = useAppInitialization();
  
  const getStageMessage = (currentStage: string) => {
    switch (currentStage) {
      case 'auth':
        return '正在驗證身份...';
      case 'workspace':
        return '正在載入工作區...';
      case 'complete':
        return '初始化完成！';
      case 'error':
        return '初始化失敗';
      default:
        return '正在準備系統...';
    }
  };

  const getStageProgress = (currentStage: string) => {
    switch (currentStage) {
      case 'auth':
        return 25;
      case 'workspace':
        return 75;
      case 'complete':
        return 100;
      case 'error':
        return 0;
      default:
        return 0;
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center">
      <div className="bg-white rounded-xl shadow-lg p-8 max-w-md w-full mx-4">
        {/* 應用 Logo 或標題 */}
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-gray-800 mb-2">
            Research Assistant
          </h1>
          <p className="text-gray-600">
            正在為您準備個人化的研究環境
          </p>
        </div>

        {/* 初始化進度 */}
        <div className="mb-6">
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm font-medium text-gray-700">
              {getStageMessage(stage)}
            </span>
            <span className="text-sm text-gray-500">
              {getStageProgress(stage)}%
            </span>
          </div>
          
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-blue-600 h-2 rounded-full transition-all duration-500 ease-out"
              style={{ width: `${getStageProgress(stage)}%` }}
            />
          </div>
        </div>

        {/* 載入指示器或錯誤訊息 */}
        {isInitializing && (
          <div className="flex items-center justify-center py-4">
            <LoadingSpinner size="medium" />
            <span className="ml-3 text-gray-600">請稍候...</span>
          </div>
        )}

        {hasError && (
          <div className="text-center py-4">
            <div className="text-red-600 mb-4">
              <svg className="w-12 h-12 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.728-.833-2.498 0L4.317 15.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
              <p className="text-sm font-medium mb-1">初始化失敗</p>
              <p className="text-xs text-gray-500">{error}</p>
            </div>
            
            <RetryButton 
              onClick={retry}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors"
            >
              重試
            </RetryButton>
          </div>
        )}

        {/* 階段指示器 */}
        <div className="flex justify-center space-x-2 mt-6">
          <StageIndicator 
            isActive={['auth', 'workspace', 'complete'].includes(stage)}
            isComplete={['workspace', 'complete'].includes(stage)}
            label="身份驗證"
          />
          <div className="w-8 h-px bg-gray-300 mt-2" />
          <StageIndicator 
            isActive={['workspace', 'complete'].includes(stage)}
            isComplete={stage === 'complete'}
            label="工作區載入"
          />
        </div>
      </div>
    </div>
  );
};

// 階段指示器組件
const StageIndicator: React.FC<{
  isActive: boolean;
  isComplete: boolean;
  label: string;
}> = ({ isActive, isComplete, label }) => {
  return (
    <div className="flex flex-col items-center">
      <div className={`
        w-4 h-4 rounded-full border-2 transition-all duration-300
        ${isComplete 
          ? 'bg-green-500 border-green-500' 
          : isActive 
            ? 'bg-blue-500 border-blue-500' 
            : 'bg-gray-200 border-gray-300'
        }
      `}>
        {isComplete && (
          <svg className="w-2.5 h-2.5 text-white m-0.5" fill="currentColor" viewBox="0 0 20 20">
            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
          </svg>
        )}
      </div>
      <span className="text-xs text-gray-500 mt-1">{label}</span>
    </div>
  );
};
```

### 步驟 3: 工作區狀態同步優化 (2 天)

#### 3.1 增強工作區 Store 的錯誤處理

**檔案**: `src/stores/workspace/workspaceStore.ts`

```typescript
// 在現有的 workspaceStore 中加入更好的錯誤處理和狀態同步
interface WorkspaceStore {
  // ... 現有屬性
  
  // 新增狀態追蹤
  initializationPromise: Promise<void> | null;
  lastSyncTime: number | null;
  
  // 新增方法
  initializeUserWorkspaces: (userId: string) => Promise<void>;
  syncWithAuth: (isAuthenticated: boolean, user: User | null) => void;
  clearAllWorkspaces: () => void;
}

export const useWorkspaceStore = create<WorkspaceStore>((set, get) => ({
  // ... 現有狀態
  initializationPromise: null,
  lastSyncTime: null,

  // 初始化用戶工作區
  initializeUserWorkspaces: async (userId: string) => {
    const store = get();
    
    // 防止重複初始化
    if (store.initializationPromise) {
      return store.initializationPromise;
    }

    const initPromise = (async () => {
      try {
        set({ isLoading: true, error: null });
        
        // 載入工作區列表
        await store.refreshWorkspaces();
        
        // 記錄同步時間
        set({ lastSyncTime: Date.now() });
        
      } catch (error) {
        console.error('Failed to initialize workspaces:', error);
        set({ 
          error: error instanceof Error ? error.message : 'Failed to initialize workspaces',
          isLoading: false 
        });
        throw error;
      } finally {
        set({ initializationPromise: null });
      }
    })();

    set({ initializationPromise: initPromise });
    return initPromise;
  },

  // 與認證狀態同步
  syncWithAuth: (isAuthenticated: boolean, user: User | null) => {
    if (!isAuthenticated || !user) {
      // 清理工作區狀態
      get().clearAllWorkspaces();
    }
  },

  // 清理所有工作區狀態
  clearAllWorkspaces: () => {
    set({
      workspaces: [],
      currentWorkspaceId: null,
      currentWorkspace: null,
      isLoading: false,
      error: null,
      initializationPromise: null,
      lastSyncTime: null
    });
  },

  // ... 其他現有方法
}));
```

## 🧪 測試驗證計劃

### 單元測試

#### 應用狀態管理測試
```typescript
// src/__tests__/hooks/useAppState.test.ts
import { renderHook, act } from '@testing-library/react';
import { useAppState } from '../../hooks/useAppState';

describe('useAppState', () => {
  test('should initialize workspace after authentication', async () => {
    const { result } = renderHook(() => useAppState());
    
    // 模擬認證成功
    act(() => {
      // 觸發認證狀態變化
    });
    
    await waitFor(() => {
      expect(result.current.initializationStage).toBe('complete');
      expect(result.current.isAppReady).toBe(true);
    });
  });

  test('should handle initialization errors gracefully', async () => {
    // 模擬初始化失敗情況
    // 驗證錯誤處理和重試機制
  });

  test('should retry initialization automatically', async () => {
    // 測試自動重試機制
  });
});
```

#### 初始化畫面測試
```typescript
// src/__tests__/components/AppInitializationScreen.test.tsx
describe('AppInitializationScreen', () => {
  test('should show correct message for each stage', () => {
    // 測試不同階段的訊息顯示
  });

  test('should show retry button on error', () => {
    // 測試錯誤狀態的重試按鈕
  });
});
```

### 整合測試

#### 狀態同步測試
```typescript
// src/__tests__/integration/authWorkspaceSync.test.ts
describe('Authentication and Workspace Sync', () => {
  test('should sync workspace state when user logs in', async () => {
    // 測試登入時的工作區狀態同步
  });

  test('should clear workspace state when user logs out', async () => {
    // 測試登出時的狀態清理
  });

  test('should handle network errors during initialization', async () => {
    // 測試網路錯誤的處理
  });
});
```

### 端到端測試

```typescript
// cypress/integration/auth-workspace-integration.spec.ts
describe('Authentication and Workspace Integration', () => {
  it('should complete full initialization flow', () => {
    // 1. 訪問應用
    cy.visit('/');
    
    // 2. 執行登入
    cy.get('[data-testid="login-button"]').click();
    
    // 3. 等待初始化畫面
    cy.get('[data-testid="initialization-screen"]').should('be.visible');
    cy.get('[data-testid="stage-auth"]').should('have.class', 'active');
    
    // 4. 等待工作區載入
    cy.get('[data-testid="stage-workspace"]').should('have.class', 'active');
    
    // 5. 確認進入主應用
    cy.get('[data-testid="main-application"]', { timeout: 10000 })
      .should('be.visible');
    
    // 6. 確認工作區已選擇
    cy.get('[data-testid="current-workspace"]')
      .should('contain.text', '我的研究');
  });

  it('should handle initialization errors', () => {
    // 測試初始化錯誤的處理
    cy.intercept('GET', '/api/workspaces/', { statusCode: 500 });
    
    cy.visit('/');
    cy.login();
    
    // 應該顯示錯誤狀態
    cy.get('[data-testid="initialization-error"]').should('be.visible');
    
    // 測試重試功能
    cy.intercept('GET', '/api/workspaces/', { fixture: 'workspaces.json' });
    cy.get('[data-testid="retry-button"]').click();
    
    cy.get('[data-testid="main-application"]', { timeout: 10000 })
      .should('be.visible');
  });
});
```

## 📋 驗收標準

### 功能驗收
- [ ] 用戶登入後自動進入初始化流程
- [ ] 初始化畫面顯示正確的進度和訊息
- [ ] 工作區載入失敗時顯示錯誤和重試選項
- [ ] 沒有工作區時自動創建預設工作區
- [ ] 初始化完成後自動進入主應用介面
- [ ] 登出時正確清理所有狀態

### 技術驗收
- [ ] 認證狀態與工作區狀態完全同步
- [ ] 錯誤處理統一且健全
- [ ] 自動重試機制正常運作
- [ ] 記憶體洩漏測試通過
- [ ] TypeScript 類型檢查通過

### 使用者體驗驗收
- [ ] 初始化過程視覺反饋清晰
- [ ] 錯誤訊息友善且可操作
- [ ] 載入時間在可接受範圍內 (< 5 秒)
- [ ] 網路錯誤時有適當的重試機制
- [ ] 整個流程感覺平滑流暢

## 📅 實施時程

### Day 1-2: 狀態管理整合
- 創建 `useAppState` Hook
- 建立 `AppStateContext`
- 單元測試

### Day 3-4: 應用結構重構
- 更新 `App.tsx`
- 創建初始化畫面
- 整合測試

### Day 5: 測試與優化
- 端到端測試
- 效能優化
- 錯誤處理改進

## 🔗 相關文檔
- [CI-01: 核心業務流程整合修復指南](./CI-01_核心業務流程整合修復指南.md)
- [HI-01: API 契約對齊修復指南](./HI-01_API契約對齊修復指南.md)

## 📋 檢查清單

### 開發前準備
- [ ] 確認現有 AuthWrapper 和 WorkspaceContext 的實作狀況
- [ ] 備份現有狀態管理相關檔案
- [ ] 準備測試環境和測試數據

### 開發中檢查
- [ ] 定期執行單元測試
- [ ] 檢查 TypeScript 編譯無錯誤
- [ ] 驗證狀態同步邏輯
- [ ] 測試錯誤處理路徑

### 完成後驗證
- [ ] 所有自動化測試通過
- [ ] 手動測試完整流程
- [ ] 效能測試通過
- [ ] 程式碼審查完成

## 📞 技術支援
如遇到技術問題，請參考：
- React Context 最佳實踐文檔
- Zustand 狀態管理指南
- TypeScript 類型定義規範 